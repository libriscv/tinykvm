#include "idt.hpp"
#include <array>
#include <cstdio>
#include <cstring>
#include <linux/kvm.h>

// 64-bit IDT entry
struct IDTentry {
	uint16_t offset_1;  // offset bits 0..15
	uint16_t selector;  // a code segment selector in GDT or LDT
	uint8_t  ist;       // 3-bit interrupt stack table offset
	uint8_t  type_attr; // type and attributes, see below
	uint16_t offset_2;  // offset bits 16..31
	uint32_t offset_3;  // 32..63
	uint32_t zero2;
};
static_assert(sizeof(IDTentry) == 16, "AMD64 IDT entries are 16-bytes");

#define IDT_GATE_INTR 0x0e
#define IDT_CPL0      0x00
#define IDT_CPL3      0x60
#define IDT_PRESENT   0x80

struct IDT
{
	/* Just enough for CPU exceptions */
	std::array<IDTentry, 32> entry;
};

union addr_helper {
	uint64_t whole;
	struct {
		uint16_t lo16;
		uint16_t hi16;
		uint32_t top32;
	};
};

static void set_entry(
	IDTentry& idt_entry,
	uint64_t handler,
	uint16_t segment_sel,
	uint8_t  attributes)
{
	addr_helper addr { .whole = handler };
	idt_entry.offset_1  = addr.lo16;
	idt_entry.offset_2  = addr.hi16;
	idt_entry.offset_3  = addr.top32;
	idt_entry.selector  = segment_sel;
	idt_entry.type_attr = attributes;
	idt_entry.ist       = 1; /* IST #1 */
	idt_entry.zero2     = 0;
}

void set_exception_handler(void* area, uint8_t vec, uint64_t handler)
{
	auto& idt = *(IDT *)area;
	set_entry(idt.entry[vec], handler, 0x28, IDT_PRESENT | IDT_CPL3 | IDT_GATE_INTR);
}

unsigned char interrupts[] = {
  0x10, 0x20, 0x45, 0x20, 0x60, 0x20, 0x10, 0x00, 0x49, 0x20, 0x54, 0x20,
  0x90, 0x90, 0x90, 0x90, 0x3d, 0x9e, 0x00, 0x00, 0x00, 0x74, 0x05, 0xe7,
  0x00, 0x48, 0x0f, 0x07, 0x56, 0x51, 0x52, 0x48, 0x81, 0xff, 0x02, 0x10,
  0x00, 0x00, 0x75, 0x18, 0xb9, 0x00, 0x01, 0x00, 0xc0, 0x89, 0xf0, 0x48,
  0xc1, 0xee, 0x20, 0x89, 0xf2, 0x0f, 0x30, 0x48, 0x31, 0xc0, 0x5a, 0x59,
  0x5e, 0x48, 0x0f, 0x07, 0x66, 0xe7, 0x00, 0xeb, 0xf5, 0x66, 0xe7, 0x60,
  0xc3, 0x48, 0xb8, 0x45, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3,
  0x48, 0x89, 0xc7, 0x66, 0xe7, 0x3c, 0xeb, 0xfb, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xe7, 0x80, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x81, 0x48, 0xcf, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x82, 0x48,
  0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xe7, 0x83, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x84, 0x48, 0xcf, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x85, 0x48,
  0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xe7, 0x86, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x87, 0x48, 0xcf, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 0xc4, 0x08,
  0x66, 0xe7, 0x88, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xe7, 0x89, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 0xc4, 0x08, 0x66, 0xe7, 0x8a, 0x48,
  0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 0xc4, 0x08,
  0x66, 0xe7, 0x8b, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x48, 0x83, 0xc4, 0x08, 0x66, 0xe7, 0x8c, 0x48, 0xcf, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 0xc4, 0x08, 0x66, 0xe7, 0x8d, 0x48,
  0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 0xc4, 0x08,
  0x66, 0xe7, 0x8e, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xe7, 0x8f, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x90, 0x48, 0xcf, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 0xc4, 0x08,
  0x66, 0xe7, 0x91, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xe7, 0x92, 0x48, 0xcf, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x93, 0x48, 0xcf, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x66, 0xe7, 0x94, 0x48,
  0xcf
};
unsigned int interrupts_len = 421;

const iasm_header& interrupt_header() {
	return *(const iasm_header*) &interrupts[0];
}

void setup_amd64_exception_regs(struct kvm_sregs& sregs, uint64_t addr)
{
	sregs.idt.base  = addr;
	sregs.idt.limit = sizeof(IDT) - 1;
}

void setup_amd64_exceptions(uint64_t addr, void* area, void* except_area)
{
	uint64_t offset = interrupt_header().vm64_exception;
	for (int i = 0; i <= 20; i++) {
		if (i == 15) continue;
		//printf("Exception handler %d at 0x%lX\n", i, offset);
		set_exception_handler(area, i, offset);
		offset += interrupt_header().vm64_except_size;
	}
	// install exception handling code
	std::memcpy(except_area, interrupts, sizeof(interrupts));
}

void print_exception_handlers(void* area)
{
	auto* idt = (IDT*) area;
	for (unsigned i = 0; i < idt->entry.size(); i++) {
		const auto& entry = idt->entry[i];
		addr_helper addr;
		addr.lo16 = entry.offset_1;
		addr.hi16 = entry.offset_2;
		addr.top32 = entry.offset_3;
		printf("IDT %u: func=0x%lX sel=0x%X p=%d dpl=%d type=0x%X ist=%u\n",
			i, addr.whole, entry.selector, entry.type_attr >> 7,
			(entry.type_attr >> 5) & 0x3, entry.type_attr & 0xF, entry.ist);
	}
}

static std::array<const char*, 32> exception_names =
{
	"Divide-by-zero Error",
	"Debug",
	"Non-Maskable Interrupt",
	"Breakpoint",
	"Overflow",
	"Bound Range Exceeded",
	"Invalid Opcode",
	"Device Not Available",
	"Double Fault",
	"Reserved",
	"Invalid TSS",
	"Segment Not Present",
	"Stack-Segment Fault",
	"General Protection Fault",
	"Page Fault",
	"Reserved",
	"x87 Floating-point Exception",
	"Alignment Check",
	"Machine Check",
	"SIMD Floating-point Exception",
	"Virtualization Exception",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Security Exception",
	"Reserved"
};

const char* exception_name(uint8_t intr) {
	return exception_names.at(intr);
}
