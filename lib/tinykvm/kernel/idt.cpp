#include "idt.hpp"
#include <array>
#include <cstdio>
#include <cstring>
#include <linux/kvm.h>

// 64-bit IDT entry
struct IDTentry {
	uint16_t offset_1;  // offset bits 0..15
	uint16_t selector;  // a code segment selector in GDT or LDT
	uint8_t  ist;       // 3-bit interrupt stack table offset
	uint8_t  type_attr; // type and attributes, see below
	uint16_t offset_2;  // offset bits 16..31
	uint32_t offset_3;  // 32..63
	uint32_t zero2;
};
static_assert(sizeof(IDTentry) == 16, "AMD64 IDT entries are 16-bytes");

#define IDT_GATE_INTR 0x0e
#define IDT_CPL0      0x00
#define IDT_CPL3      0x60
#define IDT_PRESENT   0x80

struct IDT
{
	IDTentry entry[NUM_IDT_ENTRIES];
};

union addr_helper {
	uint64_t whole;
	struct {
		uint16_t lo16;
		uint16_t hi16;
		uint32_t top32;
	};
};

static void set_entry(
	IDTentry& idt_entry,
	uint64_t handler,
	uint16_t segment_sel,
	uint8_t  attributes)
{
	addr_helper addr { .whole = handler };
	idt_entry.offset_1  = addr.lo16;
	idt_entry.offset_2  = addr.hi16;
	idt_entry.offset_3  = addr.top32;
	idt_entry.selector  = segment_sel;
	idt_entry.type_attr = attributes;
	idt_entry.ist       = 1; /* IST #1 */
	idt_entry.zero2     = 0;
}

void set_exception_handler(void* area, uint8_t vec, uint64_t handler)
{
	auto* idt = (IDT*) area;
	set_entry(idt->entry[vec], handler, 0x28, IDT_PRESENT | IDT_CPL3 | IDT_GATE_INTR);
}

unsigned char interrupts[] = {
  0x05, 0x00, 0xa0, 0xff, 0xff, 0x67, 0xc7, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x0f, 0x07, 0x90, 0xff, 0x34, 0x24, 0x66, 0xb8, 0x00, 0x00, 0x66,
  0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66,
  0xb8, 0x01, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90,
  0xff, 0x34, 0x24, 0x66, 0xb8, 0x02, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66,
  0xef, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66, 0xb8, 0x03, 0x00, 0x66,
  0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66,
  0xb8, 0x04, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90,
  0xff, 0x34, 0x24, 0x66, 0xb8, 0x05, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66,
  0xef, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66, 0xb8, 0x06, 0x00, 0x66,
  0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66,
  0xb8, 0x07, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90,
  0x66, 0xb8, 0x08, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66, 0xb8, 0x09, 0x00, 0x66,
  0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0x66, 0xb8, 0x0a, 0x00,
  0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xb8, 0x0b, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x66, 0xb8, 0x0c, 0x00, 0x66, 0xba, 0xff, 0xff,
  0x66, 0xef, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x66, 0xb8, 0x0d, 0x00,
  0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x66, 0xb8, 0x0e, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66, 0xb8, 0x0f, 0x00, 0x66,
  0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66,
  0xb8, 0x10, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90,
  0x66, 0xb8, 0x11, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66, 0xb8, 0x12, 0x00, 0x66,
  0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90, 0xff, 0x34, 0x24, 0x66,
  0xb8, 0x13, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66, 0xef, 0x90, 0x90, 0x90,
  0xff, 0x34, 0x24, 0x66, 0xb8, 0x14, 0x00, 0x66, 0xba, 0xff, 0xff, 0x66,
  0xef
};
#define EXCEPTION_HANDLER_SIZE   16

void setup_amd64_exceptions(struct kvm_sregs& sregs,
	uint64_t addr, void* area, uint64_t except_addr, void* except_area)
{
	sregs.idt.base  = addr;
	sregs.idt.limit = sizeof(IDT) - 1;
	uint64_t offset = except_addr + EXCEPTION_HANDLER_SIZE;
	for (int i = 0; i <= 20; i++) {
		if (i == 15) continue;
		//printf("Exception handler %d at 0x%lX\n", i, offset);
		set_exception_handler(area, i, offset);
		offset += EXCEPTION_HANDLER_SIZE;
	}
	// install exception handling code
	memcpy(except_area, interrupts, sizeof(interrupts));
}

void print_exception_handlers(void* area)
{
	auto* idt = (IDT*) area;
	for (unsigned i = 0; i < NUM_IDT_ENTRIES; i++) {
		const auto& entry = idt->entry[i];
		addr_helper addr;
		addr.lo16 = entry.offset_1;
		addr.hi16 = entry.offset_2;
		addr.top32 = entry.offset_3;
		printf("IDT %u: func=0x%lX sel=0x%X p=%d dpl=%d type=0x%X\n",
			i, addr.whole, entry.selector, entry.type_attr >> 7,
			(entry.type_attr >> 5) & 0x3, entry.type_attr & 0xF);
	}
}

static std::array<const char*, 32> exception_names =
{
	"Divide-by-zero Error",
	"Debug",
	"Non-Maskable Interrupt",
	"Breakpoint",
	"Overflow",
	"Bound Range Exceeded",
	"Invalid Opcode",
	"Device Not Available",
	"Double Fault",
	"Reserved",
	"Invalid TSS",
	"Segment Not Present",
	"Stack-Segment Fault",
	"General Protection Fault",
	"Page Fault",
	"Reserved",
	"x87 Floating-point Exception",
	"Alignment Check",
	"Machine Check",
	"SIMD Floating-point Exception",
	"Virtualization Exception",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"Security Exception",
	"Reserved"
};

const char* exception_name(uint8_t intr) {
	return exception_names.at(intr);
}
